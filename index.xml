<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/index.xml</link>
    <description>Recent content on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Sat, 22 Oct 2016 21:02:01 -0400</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>swagger</title>
      <link>https://networknt.github.io/light-java/example/swagger/</link>
      <pubDate>Sat, 22 Oct 2016 21:02:01 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/swagger/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a project that contains all the swagger specifications for examples. Currently, only petstore.yaml and petstore.json are there.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>routing</title>
      <link>https://networknt.github.io/light-java/example/routing/</link>
      <pubDate>Sat, 22 Oct 2016 21:00:30 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/routing/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is an example to show you how to use undertow routing handler.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>performance</title>
      <link>https://networknt.github.io/light-java/example/performance/</link>
      <pubDate>Sat, 22 Oct 2016 20:55:36 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/performance/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a example to compare performance between Spring Boot and Light Java framework. It can be found &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/performance&#34;&gt;here&lt;/a&gt;
with the testing result on my desktop.&lt;/p&gt;

&lt;p&gt;The light-java implementation is much simpler and faster(44 times faster) then Spring Boot which is the most popular API/microservices platform at the moment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>microservices</title>
      <link>https://networknt.github.io/light-java/example/microservices/</link>
      <pubDate>Sat, 22 Oct 2016 20:48:04 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/microservices/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This example contains four projects:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_a&#34;&gt;API A&lt;/a&gt; is calling &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_b&#34;&gt;API B&lt;/a&gt; and &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_c&#34;&gt;API C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;API B is calling &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_d&#34;&gt;API D&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This example shows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to build microservices&lt;/li&gt;
&lt;li&gt;How to do API to API call with light-java client component&lt;/li&gt;
&lt;li&gt;How to protect API with JWT token with scopes&lt;/li&gt;
&lt;li&gt;How to performance test APIs with wrk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a &lt;a href=&#34;https://networknt.github.io/light-java/tutorials/microservices/&#34;&gt;tutorial&lt;/a&gt; for these projects.&lt;/p&gt;

&lt;p&gt;Note: these projects are not 100% completed yet. I am going to dockerize them and then compose them with OAuth2 server.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>petstore</title>
      <link>https://networknt.github.io/light-java/example/petstore/</link>
      <pubDate>Sat, 22 Oct 2016 20:40:35 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/petstore/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/petstore&#34;&gt;Petstore&lt;/a&gt; is a generated API project based on OpenAPI specification found &lt;a href=&#34;http://petstore.swagger.io/v2/swagger.json&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This project will be updated constantly when a new version of light-java framework released or any updates in swagger-codegen.&lt;/p&gt;

&lt;p&gt;Here is the command line to generate this project from swagger-codegen directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i http://petstore.swagger.io/v2/swagger.json -l light-java -o ~/networknt/light-java-example/petstore

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Database</title>
      <link>https://networknt.github.io/light-java/example/database/</link>
      <pubDate>Sat, 22 Oct 2016 20:22:34 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/database/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This example can be found at &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/database&#34;&gt;https://github.com/networknt/light-java-example/tree/master/database&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are three parts in this projects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An API implemented on top of light-java framework.&lt;/li&gt;
&lt;li&gt;Mysql database as part of the docker compose with init script.&lt;/li&gt;
&lt;li&gt;Postgres database as part of the docker compose with init script.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The project shows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use &lt;a href=&#34;https://github.com/brettwooldridge/HikariCP&#34;&gt;HikariCP&lt;/a&gt; for JDBC connection pool.&lt;/li&gt;
&lt;li&gt;How to initialize database connection pool and plug it into light-java startup hooks.&lt;/li&gt;
&lt;li&gt;How to dockerize light-java application.&lt;/li&gt;
&lt;li&gt;How to compose databases with light-java application so that you can start all servers together.&lt;/li&gt;
&lt;li&gt;How to performance test API application with wrk.&lt;/li&gt;
&lt;li&gt;Postgres performs better than mysql on my i5 desktop.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>security</title>
      <link>https://networknt.github.io/light-java/architecture/security/</link>
      <pubDate>Thu, 20 Oct 2016 14:34:09 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/architecture/security/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Note: If this is the first time you hear about OAuth2 or you want to getting familiar with
the grant types we are using, please read this
&lt;a href=&#34;https://github.com/networknt/undertow-oauth2/wiki/OAuth2-Introduction&#34;&gt;article&lt;/a&gt; first.&lt;/p&gt;

&lt;p&gt;While designing microserivces, big monolithic application is breaking down to smaller
services that can be independently deployed or replaced. The final application will have
more http calls then a single application, how can we protect these calls between services?&lt;/p&gt;

&lt;p&gt;To protect APIs, the answer is OAuth2 and most simple and popular solution will be
simple web token as access token. The client authenticate itself on OAuth2 server and OAuth2
server issue
a simple web token (a UUID in most of the cases), then the client send the request to API
server with access token in the Authorization header. Once API server receives the request,
it has to send the access token to OAuth2 server to verify if this is valid token and if
this token is allowed to access this API. As you can see there must be a database lookup on
OAuth2 server to do that. Distributed cache help a lot but there is still a network call and
lookup for every single request. OAuth2 server eventually becomes a bottleneck and a single
point of failure.&lt;/p&gt;

&lt;p&gt;Years ago, when JWT draft spec. was out, I came up with the idea to do the
distributed security verification with JWT to replace Simple Web Token for one of the big
banks in Canada. At that time, there is nobody using JWT this way and the bank sent the design to
Paul Madson and John Bradley who are the Authors of OAuth2 and JWT specifications and got
their endorsement to use JWT this way.&lt;/p&gt;

&lt;p&gt;Here is the diagram of distributed JWT verification for microservices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_distributed_jwt.png&#34; alt=&#34;ms_distributed_jwt&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gateway</title>
      <link>https://networknt.github.io/light-java/architecture/gateway/</link>
      <pubDate>Thu, 20 Oct 2016 14:33:53 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/architecture/gateway/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;When your organization is thinking about breaking up the big monolithic
application to adopt microservices architecture, chances are there are
some vendors coming to sell their gateway solutions. Why they want to
sell you gateways and do you really need a gateway?&lt;/p&gt;

&lt;p&gt;The reason they want to sell you a gateway is because the solutions they
provided are not truely microservices as there is no gateway in the
picture of the real microservices. Their solution is coming from web services
(SOA) design and all services behind the gateway are flattened.&lt;/p&gt;

&lt;p&gt;Here is a picture of their typical solution in the beginning.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_oauth2_gateway.png&#34; alt=&#34;ms_oauth2_gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After awhile, they realized that for every request from client, there are two
calls from client and api to oauth2 server and remote calls are too heavy.&lt;/p&gt;

&lt;p&gt;Then the solution for gateway vendor is to move oauth2 server inside the
gateway so that there is no remote calls for security. Here is an updated
gateway.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_oauth2_in_gateway.png&#34; alt=&#34;ms_oauth2_in_gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With increasing volume, the monolithic gateway becomes bottleneck and the only
solutions is to horizontally scaling. That means you have a cluster of gateway
instances and gateway becomes a single point of failure. If any component fails
in gateway, all your APIs are not accessible.&lt;/p&gt;

&lt;p&gt;When you look inside the APIs protected by the gateway, you can see these APIs
are implemented in JEE containers like WebLogic/WebSphere/JBoss/SpringBoot etc.
and they don&amp;rsquo;t call each other. They are simply monolithic JEE application packaged
in ear or war and exposed REST APIs. These APIs are normally deployed in Data
Centers and lately moved to cloud. They are not real microservices at all.&lt;/p&gt;

&lt;p&gt;Some smart developers attempted to break these big application into smaller
pieces and move into the direction of microservices but gateway became a problem.
Let&amp;rsquo;s take a look at how API to API call looks like with gateway in the following
diagram.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_gateway_api_to_api.png&#34; alt=&#34;ms_gateway_api_to_api&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, when API A calls API B, although both of them are behind of the
gateway, the request has to go in front of gateway to properly
authenticate/authorize the request. Clearly, the centralized gateway design is
against the decentralized principle of microservices architecture.&lt;/p&gt;

&lt;p&gt;In my framework, the solution is to move all the cross cutting concerns to the
API framework and APIs are built on top of the framework. In another world, a
distributed gateway. Here is a diagram to show you client calls API A and API A
calls API B and API C and API B calls API D.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_distributed_gateway.png&#34; alt=&#34;ms_distributed_gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this architecture, every API instance contains functions from the framework
and act like a mini gateway embedded. Along with container orchestration tools like
Kubernetes or Docker Swarm, the traditional gateway is replaced. As there is no remote
calls between API to gateway, all the cross cutting concerns are addressed in the same
request/response chain. This gives you the best performance for your APIs. Here
is an &lt;a href=&#34;https://networknt.github.io/undertow-server/tutorials/microservices/&#34;&gt;tutorial&lt;/a&gt;
which implements the above diagram and source code for four APIs can
be found &lt;a href=&#34;https://github.com/networknt/undertow-server-example&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our framework is built on top of Undertow http core server which is very light
and serves 1.4 million &amp;ldquo;Hello World&amp;rdquo; requests on my desktop with average response
time 2ms. Is it 44 times faster then the most popular REST container Sprint Boot.&lt;/p&gt;

&lt;p&gt;The performance test code can be found in
&lt;a href=&#34;https://github.com/networknt/undertow-server-example/tree/master/performance&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the above diagram, OAuth2 server is an independent entity and you might ask
if it is a bottleneck. I have written another &lt;a href=&#34;https://networknt.github.io/light-java/architecture/security&#34;&gt;document&lt;/a&gt; to address it with
distributed JWT token verification and client credentials token caching and renewal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>https://networknt.github.io/light-java/getting-started/</link>
      <pubDate>Tue, 18 Oct 2016 07:00:45 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/getting-started/</guid>
      <description>

&lt;h2 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h2&gt;

&lt;p&gt;The easiest way to start your API project is from OpenAPI specification and here is a video to
show you how to generate a project from swagger spec.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/xSJhF1LcE0Q&#34;&gt;light-java-getting-started&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metrics</title>
      <link>https://networknt.github.io/light-java/middleware/metrics/</link>
      <pubDate>Sat, 15 Oct 2016 20:42:32 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/metrics/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Metrics handler collects the API runtime information and report to Influxdb periodically
(5 minutes to 15 minutes based on the volume of the API). A Grafana instance is hooked to Influxdb
to output the metrics on dashboard from two different perspectives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Client oriented - client centric info to show how many APIs to call and each API runtime info.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;API oriented - API centric info to show how many clients is calling this API.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Here is an example of configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Metrics handler configuration&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;influxdbHost&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;influxdbPort&amp;quot;: 8086,
  &amp;quot;influxdbName&amp;quot;: &amp;quot;metrics&amp;quot;,
  &amp;quot;influxdbUser&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;influxdbPass&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;reportInMinutes&amp;quot;: 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;influxdb-and-grafana&#34;&gt;InfluxDB and Grafana&lt;/h2&gt;

&lt;p&gt;Here is the docker-compose.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;influxdb:
  image: influxdb:latest
  container_name: influxdb
  ports:
    - &amp;quot;8083:8083&amp;quot;
    - &amp;quot;8086:8086&amp;quot;

grafana:
  image: grafana/grafana:latest
  container_name: grafana
  ports:
    - &amp;quot;3000:3000&amp;quot;
  links:
    - influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metrics-collected&#34;&gt;Metrics Collected&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/measurements.png&#34; alt=&#34;measurements&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, there two perspectives in collecting metrics info. The measurements started with clientId are client
centric info and the measurements started with API name are API centric info.&lt;/p&gt;

&lt;p&gt;Currently, we are collecting 5 metrics each.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/client_metrics.png&#34; alt=&#34;client metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for client f7d42348-c647-4efb-a52d-4c5787421e72&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/api_metrics.png&#34; alt=&#34;api metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for API swagger_petstore.&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;h2 id=&#34;customization&#34;&gt;Customization&lt;/h2&gt;

&lt;p&gt;The default implementation is based on InfluxDB and Grafana which are the most popular combination
for docker containers. However, the database and dashboard can be replaced easily with another
reporter implementation. To replace it, change the MetricsHandler to use another reporter instead of
InfluxDB.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Server</title>
      <link>https://networknt.github.io/light-java/middleware/server/</link>
      <pubDate>Sat, 15 Oct 2016 19:27:03 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/server/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This module is responsible for managing life cycle of the embedded Undertow core http server. It starts the
server and initializes all middleware plugins along with route handler providers. It stops the server and
allow the resources to be released even someone click ctrl+c.&lt;/p&gt;

&lt;h2 id=&#34;middleware&#34;&gt;Middleware&lt;/h2&gt;

&lt;p&gt;Middleware plugins are the key components in the framework as they perform the heavy lifting behind the
scene. These components address the cross cutting concerns for all API implementation so that API developers
can focus on their domain logic only. Each component will have a config file (same name but with .json ext)
to control if the component will be enabled and its behavior. The framework has provide a list of the
middleware plugins and experience developers can add other plugins into the request/response chain.&lt;/p&gt;

&lt;p&gt;To add your own middleware plugins, update com.networknt.handler.MiddlewareHandler in
your API project folder src/main/resources/META-INF/services&lt;/p&gt;

&lt;p&gt;Here is the default middleware configuration generated by &lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This file is generated and should not be changed unless you want to plug in more handlers into the handler chain
# for cross cutting concerns. In most cases, you should replace some of the default handlers with your own implementation
# Please note: the sequence of these handlers are very important.

#Validator
com.networknt.validator.ValidatorHandler
#FullAudit
com.networknt.audit.FullAuditHandler
#SimpleAudit
com.networknt.audit.SimpleAuditHandler
#Body
com.networknt.body.BodyHandler
#Security
com.networknt.security.JwtVerifyHandler
#Swagger
com.networknt.swagger.SwaggerHandler
#Metrics
com.networknt.metrics.MetricsHandler
#Exception
com.networknt.exception.ExceptionHandler


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;route-provider&#34;&gt;Route Provider&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt; generates all the handlers and corresponding
test cases based on OpenAPI specification. It also generate PathHandlerProvider to group these handlers
together. This class is loaded by the server via Java SPI. The config file
com.networknt.server.HandlerProvider can be found at /src/main/resources/META-INF/services&lt;/p&gt;

&lt;p&gt;Here is an example of the config.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;io.swagger.handler.PathHandlerProvider

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;server.json is the configuration file for this module. To make it simpler, it only ip and port are
configurable at the moment. Other server parameters are set for the best performance assuming clould
deployment. In the future, these parameters might be exposed in the server.json.&lt;/p&gt;

&lt;p&gt;Here is an exmaple of server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;port&amp;quot;: 8080
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Road Map</title>
      <link>https://networknt.github.io/light-java/roadmap/</link>
      <pubDate>Sat, 15 Oct 2016 19:19:57 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/roadmap/</guid>
      <description>&lt;p&gt;The REST API framework is used by one of the big banks in Canada and is in a process to be production
ready.&lt;/p&gt;

&lt;p&gt;The short term goal is to make sure the API framework is production ready.&lt;/p&gt;

&lt;p&gt;The mid term goal is to support GraphQL in the framework and make undertow-oauth2 server production ready.&lt;/p&gt;

&lt;p&gt;The long term goal is to build an API portal so that all APIs can be managed by the portal/marketplace.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Client</title>
      <link>https://networknt.github.io/light-java/middleware/client/</link>
      <pubDate>Wed, 12 Oct 2016 19:59:08 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/client/</guid>
      <description>

&lt;p&gt;Client is used to call APIs from the following sources:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web server&lt;/li&gt;
&lt;li&gt;Standalone Application&lt;/li&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It provides method to get authorization jwt token and automatically gets client
credentials token for scopes in API to API calls.&lt;/p&gt;

&lt;h1 id=&#34;sync-client&#34;&gt;Sync Client&lt;/h1&gt;

&lt;p&gt;This is a wrapper of Apache HttpClient with built-in connection pools and TLS
support. It can be used to call another API in the request context.&lt;/p&gt;

&lt;h1 id=&#34;async-client&#34;&gt;Async Client&lt;/h1&gt;

&lt;p&gt;This is a wrapper of Apache HttpAsyncClient with built-in connection pools and
TLS support. It should be used it multiple APIs will be called in the request
context.&lt;/p&gt;

&lt;h1 id=&#34;client-credentials-token-renew&#34;&gt;Client Credentials token renew&lt;/h1&gt;

&lt;p&gt;The renew of token happens behind the scene and it supports circuit breaker
is OAuth2 server is down or busy. It renew the token pro-actively before the
current one is expired and let all requests go with the current token. It only
block other request if the current request is trying to renew an expired token.
When token renew in this case fails, all request will be rejected with timeout
and subsequent requests the same until a grace period is passed so that the
renew process is start again.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Development Flow</title>
      <link>https://networknt.github.io/light-java/management/flow/</link>
      <pubDate>Wed, 12 Oct 2016 19:30:08 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/management/flow/</guid>
      <description>

&lt;h2 id=&#34;development-flow&#34;&gt;Development Flow&lt;/h2&gt;

&lt;p&gt;There are three flows running in parallel but not started at the same time in API development&lt;/p&gt;

&lt;p&gt;API Specification starts the first and it will be done by data architect and business
analyst.&lt;/p&gt;

&lt;p&gt;API implementation starts when the first release of the specification is done by API
developers.&lt;/p&gt;

&lt;p&gt;Client implementations start almost the same time as API implementation team for mock API can
be generated from swagger specification immediately.&lt;/p&gt;

&lt;p&gt;During the process, specification might be changed and the changes will be propagated
to API implementation team and Client implementation team(s).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/api_flow.png&#34; alt=&#34;API Flow&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>validator</title>
      <link>https://networknt.github.io/light-java/middleware/validator/</link>
      <pubDate>Wed, 12 Oct 2016 19:13:19 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/validator/</guid>
      <description>

&lt;p&gt;The framework encourages design driven implementation so swagger specification
should be done before the implementation starts. With the swagger-codegen
undertow generator, the server stub can be generated and start running within
minutes. However, we cannot rely on generator for validation as specification
will be changed along  the life cycle of the API. This is why we have provided
a validator that works on top of the specification at runtime. In this way,
the generator should only be used once and the validator will take the latest
spec. and validate according the spec. at runtime.&lt;/p&gt;

&lt;h1 id=&#34;fail-fast&#34;&gt;Fail fast&lt;/h1&gt;

&lt;p&gt;As you may noticed that our Status object only supports one code and message.
This is the indication the framework validation is designed as fail fast.
Whenever there is an error, the server will stop processing the request and
return the error to the consumer immediately. There are two reasons on this
design:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Security - you don&amp;rsquo;t want to return so many errors if someone is trying
to hack your server.&lt;/li&gt;
&lt;li&gt;Performance - you don&amp;rsquo;t want to spend resource to handle invalid request
to the next step.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;validatorhandler&#34;&gt;ValidatorHandler&lt;/h1&gt;

&lt;p&gt;This is the entry point of the validator and it is injected during server
start up if validator.json enableValidator is true. By default, only
RequestValidator will be called. However, ResponseValidator can be enabled
by setting enableResponseValidator to true in validator.json.&lt;/p&gt;

&lt;h1 id=&#34;requestvalidator&#34;&gt;RequestValidator&lt;/h1&gt;

&lt;p&gt;It will validate the following:
* uri
* method
* header
* query parameters
* path parameters
* body if available&lt;/p&gt;

&lt;p&gt;When necessary, schema validator will be called to do json schema validation.&lt;/p&gt;

&lt;h1 id=&#34;responsevalidator&#34;&gt;ResponseValidator&lt;/h1&gt;

&lt;p&gt;It will validate the following:
* header
* response code
* body if available&lt;/p&gt;

&lt;p&gt;when necessary, json schema validator will be called.&lt;/p&gt;

&lt;h1 id=&#34;schemavalidator&#34;&gt;SchemaValidator&lt;/h1&gt;

&lt;p&gt;If schema is defined in swagger.json, then the &lt;a href=&#34;https://github.com/networknt/json-schema-validator&#34;&gt;json-schema-validator&lt;/a&gt; will be called to validate the input against a json schema defined in draft v4.&lt;/p&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;p&gt;In order to test validator, the test suite starts an undertow server and serves
petstore api for testing. It is a demo on how to unit test your API during
development.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>