<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/index.xml</link>
    <description>Recent content on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Sun, 23 Oct 2016 12:26:20 -0400</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Client</title>
      <link>https://networknt.github.io/light-java/other/client/</link>
      <pubDate>Sun, 23 Oct 2016 12:26:20 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/client/</guid>
      <description>

&lt;p&gt;Client is used to call APIs from the following sources:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web server&lt;/li&gt;
&lt;li&gt;Standalone Application&lt;/li&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It provides method to get authorization jwt token and automatically gets client
credentials token for scopes in API to API calls.&lt;/p&gt;

&lt;h1 id=&#34;sync-client&#34;&gt;Sync Client&lt;/h1&gt;

&lt;p&gt;This is a wrapper of Apache HttpClient with built-in connection pools and TLS
support. It can be used to call another API in the request context.&lt;/p&gt;

&lt;h1 id=&#34;async-client&#34;&gt;Async Client&lt;/h1&gt;

&lt;p&gt;This is a wrapper of Apache HttpAsyncClient with built-in connection pools and
TLS support. It should be used it multiple APIs will be called in the request
context.&lt;/p&gt;

&lt;h1 id=&#34;client-credentials-token-renew&#34;&gt;Client Credentials token renew&lt;/h1&gt;

&lt;p&gt;The renew of token happens behind the scene and it supports circuit breaker
is OAuth2 server is down or busy. It renew the token pro-actively before the
current one is expired and let all requests go with the current token. It only
block other request if the current request is trying to renew an expired token.
When token renew in this case fails, all request will be rejected with timeout
and subsequent requests the same until a grace period is passed so that the
renew process is start again.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sanitizer</title>
      <link>https://networknt.github.io/light-java/middleware/sanitizer/</link>
      <pubDate>Sun, 23 Oct 2016 10:35:04 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/sanitizer/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a middleware that addresses cross site scripting concerns. It encodes the header
and body according to the configuration. As body encoding depends on
&lt;a href=&#34;https://networknt.github.io/light-java/middleware/body/&#34;&gt;Body&lt;/a&gt; middleware, it has to be
plugged into the request/response chain after Body.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>swagger</title>
      <link>https://networknt.github.io/light-java/example/swagger/</link>
      <pubDate>Sat, 22 Oct 2016 21:02:01 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/swagger/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a project that contains all the swagger specifications for examples. Currently, only petstore.yaml and petstore.json are there.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>routing</title>
      <link>https://networknt.github.io/light-java/example/routing/</link>
      <pubDate>Sat, 22 Oct 2016 21:00:30 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/routing/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is an example to show you how to use undertow routing handler.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>performance</title>
      <link>https://networknt.github.io/light-java/example/performance/</link>
      <pubDate>Sat, 22 Oct 2016 20:55:36 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/performance/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This is a example to compare performance between Spring Boot and Light Java framework. It can be found &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/performance&#34;&gt;here&lt;/a&gt;
with the testing result on my desktop.&lt;/p&gt;

&lt;p&gt;The light-java implementation is much simpler and faster(44 times faster) then Spring Boot which is the most popular API/microservices platform at the moment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>microservices</title>
      <link>https://networknt.github.io/light-java/example/microservices/</link>
      <pubDate>Sat, 22 Oct 2016 20:48:04 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/microservices/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This example contains four projects:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_a&#34;&gt;API A&lt;/a&gt; is calling &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_b&#34;&gt;API B&lt;/a&gt; and &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_c&#34;&gt;API C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;API B is calling &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/api_d&#34;&gt;API D&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This example shows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to build microservices&lt;/li&gt;
&lt;li&gt;How to do API to API call with light-java client component&lt;/li&gt;
&lt;li&gt;How to protect API with JWT token with scopes&lt;/li&gt;
&lt;li&gt;How to performance test APIs with wrk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a &lt;a href=&#34;https://networknt.github.io/light-java/tutorials/microservices/&#34;&gt;tutorial&lt;/a&gt; for these projects.&lt;/p&gt;

&lt;p&gt;Note: these projects are not 100% completed yet. I am going to dockerize them and then compose them with OAuth2 server.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>petstore</title>
      <link>https://networknt.github.io/light-java/example/petstore/</link>
      <pubDate>Sat, 22 Oct 2016 20:40:35 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/petstore/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/petstore&#34;&gt;Petstore&lt;/a&gt; is a generated API project based on OpenAPI specification found &lt;a href=&#34;http://petstore.swagger.io/v2/swagger.json&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This project will be updated constantly when a new version of light-java framework released or any updates in swagger-codegen.&lt;/p&gt;

&lt;p&gt;Here is the command line to generate this project from swagger-codegen directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate -i http://petstore.swagger.io/v2/swagger.json -l light-java -o ~/networknt/light-java-example/petstore

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>database</title>
      <link>https://networknt.github.io/light-java/example/database/</link>
      <pubDate>Sat, 22 Oct 2016 20:22:34 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/example/database/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;This example can be found at &lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/database&#34;&gt;https://github.com/networknt/light-java-example/tree/master/database&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are three parts in this projects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An API implemented on top of light-java framework.&lt;/li&gt;
&lt;li&gt;Mysql database as part of the docker compose with init script.&lt;/li&gt;
&lt;li&gt;Postgres database as part of the docker compose with init script.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The project shows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use &lt;a href=&#34;https://github.com/brettwooldridge/HikariCP&#34;&gt;HikariCP&lt;/a&gt; for JDBC connection pool.&lt;/li&gt;
&lt;li&gt;How to initialize database connection pool and plug it into light-java startup hooks.&lt;/li&gt;
&lt;li&gt;How to dockerize light-java application.&lt;/li&gt;
&lt;li&gt;How to compose databases with light-java application so that you can start all servers together.&lt;/li&gt;
&lt;li&gt;How to performance test API application with wrk.&lt;/li&gt;
&lt;li&gt;Postgres performs better than mysql on my i5 desktop.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>security</title>
      <link>https://networknt.github.io/light-java/architecture/security/</link>
      <pubDate>Thu, 20 Oct 2016 14:34:09 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/architecture/security/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Note: If this is the first time you hear about OAuth2 or you want to get familiar with
the grant types we are using, please read this
&lt;a href=&#34;https://github.com/networknt/undertow-oauth2/wiki/OAuth2-Introduction&#34;&gt;article&lt;/a&gt; first.&lt;/p&gt;

&lt;p&gt;While designing microserivces, big monolithic application is breaking down to smaller
services that can be independently deployed or replaced. The final application will have
more http calls than a single application, how can we protect these calls between services?&lt;/p&gt;

&lt;p&gt;To protect APIs/services, the answer is OAuth2 and most simple and popular solution will be
simple web token as access token. The client authenticates itself on OAuth2 server and OAuth2
server issues
a simple web token (a UUID in most of the cases), then the client sends the request to API
server with access token in the Authorization header. Once API server receives the request,
it has to send the access token to OAuth2 server to verify if this is valid token and if
this token is allowed to access this API. As you can see there must be a database lookup on
OAuth2 server to do that. Distributed cache help a lot but there is still a network call and
lookup for every single request. OAuth2 server eventually becomes a bottleneck and a single
point of failure.&lt;/p&gt;

&lt;p&gt;Years ago, when JWT draft specification was out, I came up with the idea to do the
distributed security verification with JWT to replace Simple Web Token for one of the big
banks in Canada. At that time, there was nobody using JWT this way and the bank sent the design to
Paul Madson and John Bradley who are the Authors of OAuth2 and JWT specifications and got
their endorsements to use JWT this way.&lt;/p&gt;

&lt;h1 id=&#34;distributed-jwt-verification&#34;&gt;Distributed JWT Verification&lt;/h1&gt;

&lt;p&gt;Here is the diagram of distributed JWT verification for microservices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_distributed_jwt.png&#34; alt=&#34;ms_distributed_jwt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Client1 is a web server and it has client1 as client_id.&lt;/li&gt;
&lt;li&gt;API A is a microservice and it has apia as client_id and it requires a.r scope to access.&lt;/li&gt;
&lt;li&gt;API B is a microserivce and it has apib as client_id and it requires b.r scope to access.&lt;/li&gt;
&lt;li&gt;API C is a microservice and it has apic as client_id and it requires c.r scope to access.&lt;/li&gt;
&lt;li&gt;API D is a microservice and it has apid as client_id and it requires d.r scope to access.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;user-trigger-the-authentication&#34;&gt;User trigger the authentication&lt;/h3&gt;

&lt;p&gt;When user clicks the login button or accesses resource that is protected, he will be
redirect to OAuth2 server to authenticate himself. After input username and password, an
authorization code is redirected back to the browser. The client1 will handle the redirect
url and get the authorization code. By sending client1 client_id, client_secret and
authorization code from user to OAuth2 server, Client1 gets a JWT token with&lt;/p&gt;

&lt;p&gt;user_id = user1&lt;/p&gt;

&lt;p&gt;client_id = client1&lt;/p&gt;

&lt;p&gt;scope = [a.r]&lt;/p&gt;

&lt;p&gt;This token will be put into the Authorization header of the request to API A. When API A
receives the request, it verifies the JWT token with public key issued by OAuth2 server with
the security middleware in the framework. If the signature verification is successful, it
will verify the scope in the token against the swagger specification defined for the
endpoint Client1 is accessing. As a.r is required and it is in the JWT scope, it allows
the access.&lt;/p&gt;

&lt;h3 id=&#34;api-a-calls-api-b-and-api-c&#34;&gt;API A calls API B and API C&lt;/h3&gt;

&lt;p&gt;Now API A needs to call API B and API C to fulfill the request. As this is API to API call or
service to service call, there is no user id involved and Client Credentials flow will be
used here to get another JWT token to B and C. The original JWT token doesn&amp;rsquo;t have the scopes
to access B and C as Client1 does not even care A is calling B and C. So here API A needs to
get a token associate with client_id apia which has proper scope to access API B and API C.&lt;/p&gt;

&lt;p&gt;This token will have the following claims.&lt;/p&gt;

&lt;p&gt;client_id = apia&lt;/p&gt;

&lt;p&gt;scope = [b.r c.r]&lt;/p&gt;

&lt;p&gt;As the original token has the original user_id, it is carried in the entire service to service
calls so that each service has a chance to do role based or user based authorization if it is
necessary. The new client_credentials token will be passed in the request header &amp;ldquo;X-Scope-Token&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;api-b-and-api-c-tokens-verification&#34;&gt;API B and API C tokens verification&lt;/h3&gt;

&lt;p&gt;The tokens verification on API B and API C are the same. So le&amp;rsquo;t use API B as an example to
explain the verification process.&lt;/p&gt;

&lt;p&gt;When API B receives the request, it first check the Authorization token to make sure it is valid. Then
if scope verification is enabled, it will check if &amp;lsquo;X-Scope-Token&amp;rsquo; header exists. If yes, it will verify
it and match the scope with endpoint defined scope. If scope matching is failed, it will fall back
to Authorization token to see if it has the scope required. If none of the tokens has the scope required,
an error will be sent back to the caller.&lt;/p&gt;

&lt;h3 id=&#34;api-b-calls-api-d&#34;&gt;API B calls API D&lt;/h3&gt;

&lt;p&gt;The process is very similar like API A calls API B and API C. A client credentials token will be
retrieved by API B from OAuth2 server and it has the following claims.&lt;/p&gt;

&lt;p&gt;client_id = apib&lt;/p&gt;

&lt;p&gt;scope = [d.r]&lt;/p&gt;

&lt;h3 id=&#34;api-d-token-verification&#34;&gt;API D token verification&lt;/h3&gt;

&lt;p&gt;Similar like API B and API C tokens verification.&lt;/p&gt;

&lt;h1 id=&#34;client-credentials-scope-token-cache&#34;&gt;Client Credentials / Scope Token Cache&lt;/h1&gt;

&lt;p&gt;As described above, for every API to API call, the caller must pass in a scope token in addition to
the original token. Unlike the original token which is associated with a user, the scope token is only
associated with a client (API / service) and it won&amp;rsquo;t be expired after a period configured on OAuth2
server. So it is not necessary to get the new scope token for every API to API call. The token is
retrieved and cached in memory until it is about to be expired then a new token will be retrieved.&lt;/p&gt;

&lt;p&gt;The entire token renew process is managed
by &lt;a href=&#34;https://networknt.github.io/light-java/other/client/&#34;&gt;Client&lt;/a&gt; module provided in the light-java
framework. This client module encapsulate a lot of features to help API to API calls.&lt;/p&gt;

&lt;h1 id=&#34;authorization-token-cache&#34;&gt;Authorization Token Cache&lt;/h1&gt;

&lt;p&gt;The original token normally will be cached in the web server session so that the subsequent calls
from the same user can use the cached token.&lt;/p&gt;

&lt;h1 id=&#34;single-sign-on&#34;&gt;Single Sign On&lt;/h1&gt;

&lt;p&gt;As the end user login is managed by OAuth2 server, there is a session established between user&amp;rsquo;s
browser and OAuth2 server. The the user switch to another tab on his browser to access another
application, the login on OAuth2 is not necessary and a new authorization code will immediately
redirected back.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gateway</title>
      <link>https://networknt.github.io/light-java/architecture/gateway/</link>
      <pubDate>Thu, 20 Oct 2016 14:33:53 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/architecture/gateway/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;When your organization is thinking about breaking up the big monolithic
application to adopt microservices architecture, chances are there are
some vendors coming to sell their gateway solutions. Why they want to
sell you gateways and do you really need a gateway?&lt;/p&gt;

&lt;p&gt;The reason they want to sell you a gateway is because the solutions they
provided are not truely microservices as there is no gateway in the
picture of the real microservices. Their solution is coming from web services
(SOA) design and all services behind the gateway are flattened.&lt;/p&gt;

&lt;p&gt;Here is a picture of their typical solution in the beginning.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_oauth2_gateway.png&#34; alt=&#34;ms_oauth2_gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After awhile, they realized that for every request from client, there are two
calls from client and api to oauth2 server and remote calls are too heavy.&lt;/p&gt;

&lt;p&gt;Then the solution for gateway vendors is to move oauth2 server inside the
gateway so that there is no remote calls for security. Here is an updated
gateway.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_oauth2_in_gateway.png&#34; alt=&#34;ms_oauth2_in_gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With increasing volume, the monolithic gateway becomes bottleneck and the only
solutions is horizontal scaling. That means you have a cluster of gateway
instances and gateway becomes a single point of failure. If any component fails
in gateway, all your APIs are not accessible.&lt;/p&gt;

&lt;p&gt;When you look inside the APIs protected by the gateway, you can see these APIs
are implemented in JEE containers like WebLogic/WebSphere/JBoss/SpringBoot etc.
and they don&amp;rsquo;t call each other. They are simply monolithic JEE application packaged
in ear or war and exposed REST APIs. These APIs are normally deployed in Data
Centers and lately moved to cloud. They are not real microservices at all.&lt;/p&gt;

&lt;p&gt;Some smart developers attempted to break these big application into smaller
pieces and move into the direction of microservices but gateway became a problem.
Let&amp;rsquo;s take a look at how API to API call looks like with gateway in the following
diagram.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_gateway_api_to_api.png&#34; alt=&#34;ms_gateway_api_to_api&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, when API A calls API B, although both of them are behind of the
gateway, the request has to go in front of gateway to properly
authenticate/authorize the request. Clearly, the centralized gateway design is
against the decentralized principle of microservices architecture.&lt;/p&gt;

&lt;p&gt;In my framework, the solution is to move all the cross cutting concerns to the
API framework and APIs are built on top of the framework. In another word, a
distributed gateway. Here is a diagram to show you client calls API A and API A
calls API B and API C and API B calls API D.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/ms_distributed_gateway.png&#34; alt=&#34;ms_distributed_gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this architecture, every API instance contains functions from the framework
and act like a mini gateway embedded. Along with container orchestration tools like
Kubernetes or Docker Swarm, the traditional gateway is replaced. As there is no remote
calls between API to gateway, all the cross cutting concerns are addressed in the same
request/response chain. This gives you the best performance for your APIs. Here
is an &lt;a href=&#34;https://networknt.github.io/light-java/tutorials/microservices/&#34;&gt;tutorial&lt;/a&gt;
which implements the above diagram and source code for four APIs can
be found &lt;a href=&#34;https://github.com/networknt/light-java-example&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our framework is built on top of Undertow http core server which is very light
and serves 1.4 million &amp;ldquo;Hello World&amp;rdquo; requests on my desktop with average response
time 2ms. Is it 44 times faster then the most popular REST container Sprint Boot.&lt;/p&gt;

&lt;p&gt;The performance test code can be found in
&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/performance&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the above diagram, OAuth2 server is an independent entity and you might ask
if it is a bottleneck. I have written another &lt;a href=&#34;https://networknt.github.io/light-java/architecture/security&#34;&gt;document&lt;/a&gt; to address it with
distributed JWT token verification and client credentials token caching and renewal.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>https://networknt.github.io/light-java/getting-started/</link>
      <pubDate>Tue, 18 Oct 2016 07:00:45 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/getting-started/</guid>
      <description>

&lt;h2 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h2&gt;

&lt;p&gt;The easiest way to start your API project is from OpenAPI specification and here is a video to
show you how to generate a project from swagger spec.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/xSJhF1LcE0Q&#34;&gt;light-java-getting-started&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metrics</title>
      <link>https://networknt.github.io/light-java/middleware/metrics/</link>
      <pubDate>Sat, 15 Oct 2016 20:42:32 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/metrics/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Metrics handler collects the API runtime information and report to Influxdb periodically
(5 minutes to 15 minutes based on the volume of the API). A Grafana instance is hooked to Influxdb
to output the metrics on dashboard from two different perspectives:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Client oriented - client centric info to show how many APIs to call and each API runtime info.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;API oriented - API centric info to show how many clients is calling this API.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Here is an example of configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Metrics handler configuration&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;influxdbHost&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;influxdbPort&amp;quot;: 8086,
  &amp;quot;influxdbName&amp;quot;: &amp;quot;metrics&amp;quot;,
  &amp;quot;influxdbUser&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;influxdbPass&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;reportInMinutes&amp;quot;: 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;influxdb-and-grafana&#34;&gt;InfluxDB and Grafana&lt;/h2&gt;

&lt;p&gt;Here is the docker-compose.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;influxdb:
  image: influxdb:latest
  container_name: influxdb
  ports:
    - &amp;quot;8083:8083&amp;quot;
    - &amp;quot;8086:8086&amp;quot;

grafana:
  image: grafana/grafana:latest
  container_name: grafana
  ports:
    - &amp;quot;3000:3000&amp;quot;
  links:
    - influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metrics-collected&#34;&gt;Metrics Collected&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/measurements.png&#34; alt=&#34;measurements&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, there two perspectives in collecting metrics info. The measurements started with clientId are client
centric info and the measurements started with API name are API centric info.&lt;/p&gt;

&lt;p&gt;Currently, we are collecting 5 metrics each.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/client_metrics.png&#34; alt=&#34;client metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for client f7d42348-c647-4efb-a52d-4c5787421e72&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/api_metrics.png&#34; alt=&#34;api metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is request count for API swagger_petstore.&lt;/p&gt;

&lt;p&gt;The first column is timestamp and value column is the value for this time series. Other columns are tags and they
are endpoint, hostname/container id, ipAddress and version.&lt;/p&gt;

&lt;h2 id=&#34;customization&#34;&gt;Customization&lt;/h2&gt;

&lt;p&gt;The default implementation is based on InfluxDB and Grafana which are the most popular combination
for docker containers. However, the database and dashboard can be replaced easily with another
reporter implementation. To replace it, change the MetricsHandler to use another reporter instead of
InfluxDB.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Server</title>
      <link>https://networknt.github.io/light-java/middleware/server/</link>
      <pubDate>Sat, 15 Oct 2016 19:27:03 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/server/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This module is responsible for managing life cycle of the embedded Undertow core http server. It starts the
server and initializes all middleware plugins along with route handler providers. It stops the server and
allow the resources to be released even someone click ctrl+c.&lt;/p&gt;

&lt;h2 id=&#34;middleware&#34;&gt;Middleware&lt;/h2&gt;

&lt;p&gt;Middleware plugins are the key components in the framework as they perform the heavy lifting behind the
scene. These components address the cross cutting concerns for all API implementation so that API developers
can focus on their domain logic only. Each component will have a config file (same name but with .json ext)
to control if the component will be enabled and its behavior. The framework has provide a list of the
middleware plugins and experience developers can add other plugins into the request/response chain.&lt;/p&gt;

&lt;p&gt;To add your own middleware plugins, update com.networknt.handler.MiddlewareHandler in
your API project folder src/main/resources/META-INF/services&lt;/p&gt;

&lt;p&gt;Here is the default middleware configuration generated by &lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This file is generated and should not be changed unless you want to plug in more handlers into the handler chain
# for cross cutting concerns. In most cases, you should replace some of the default handlers with your own implementation
# Please note: the sequence of these handlers are very important.

#Validator
com.networknt.validator.ValidatorHandler
#FullAudit
com.networknt.audit.FullAuditHandler
#SimpleAudit
com.networknt.audit.SimpleAuditHandler
#Body
com.networknt.body.BodyHandler
#Security
com.networknt.security.JwtVerifyHandler
#Swagger
com.networknt.swagger.SwaggerHandler
#Metrics
com.networknt.metrics.MetricsHandler
#Exception
com.networknt.exception.ExceptionHandler


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;route-provider&#34;&gt;Route Provider&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt; generates all the handlers and corresponding
test cases based on OpenAPI specification. It also generate PathHandlerProvider to group these handlers
together. This class is loaded by the server via Java SPI. The config file
com.networknt.server.HandlerProvider can be found at /src/main/resources/META-INF/services&lt;/p&gt;

&lt;p&gt;Here is an example of the config.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;io.swagger.handler.PathHandlerProvider

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;server.json is the configuration file for this module. To make it simpler, it only ip and port are
configurable at the moment. Other server parameters are set for the best performance assuming clould
deployment. In the future, these parameters might be exposed in the server.json.&lt;/p&gt;

&lt;p&gt;Here is an exmaple of server.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;server config&amp;quot;,
  &amp;quot;ip&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;port&amp;quot;: 8080
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Road Map</title>
      <link>https://networknt.github.io/light-java/roadmap/</link>
      <pubDate>Sat, 15 Oct 2016 19:19:57 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/roadmap/</guid>
      <description>&lt;p&gt;The REST API framework is used by one of the big banks in Canada and is in a process to be production
ready.&lt;/p&gt;

&lt;p&gt;The short term goal is to make sure the API framework is production ready.&lt;/p&gt;

&lt;p&gt;The mid term goal is to support GraphQL in the framework and make undertow-oauth2 server production ready.&lt;/p&gt;

&lt;p&gt;The long term goal is to build an API portal so that all APIs can be managed by the portal/marketplace.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Development Flow</title>
      <link>https://networknt.github.io/light-java/management/flow/</link>
      <pubDate>Wed, 12 Oct 2016 19:30:08 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/management/flow/</guid>
      <description>

&lt;h2 id=&#34;development-flow&#34;&gt;Development Flow&lt;/h2&gt;

&lt;p&gt;There are three flows running in parallel but not started at the same time in API development&lt;/p&gt;

&lt;p&gt;API Specification starts the first and it will be done by data architect and business
analyst.&lt;/p&gt;

&lt;p&gt;API implementation starts when the first release of the specification is done by API
developers.&lt;/p&gt;

&lt;p&gt;Client implementations start almost the same time as API implementation team for mock API can
be generated from swagger specification immediately.&lt;/p&gt;

&lt;p&gt;During the process, specification might be changed and the changes will be propagated
to API implementation team and Client implementation team(s).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/api_flow.png&#34; alt=&#34;API Flow&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>